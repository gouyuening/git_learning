<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>绑定this call apply bind</title>
  </head>
  <body>
    <div>哈哈哈</div>
    <div>GIT学习</div>
    <img src="img/logo.png"/>
    <div>bare repository</div>
    <div>裸仓库</div>
    <script>
      var n = 123;
      var obj = {
        n: 568
      }

      function a() {
        console.log(this.n)
      }
      a.call(obj)
      a.call()
      //call的第一个参数就是this所要指向的那个对象
      function add(a, b) {
        return a + b;
      }

      console.log(add.call(this, 1, 2));

      //call方法的一个应用是调用对象的原生方法。
      var child = {};
      var childToStr = child.hasOwnProperty('toString') // false
      console.log("child hasOwnProperty " + childToStr)

      // 覆盖掉继承的 hasOwnProperty 方法
      child.hasOwnProperty = function() {
        return true;
      };
      var childToStr2 = child.hasOwnProperty('toString') // true
      console.log("child hasOwnProperty " + childToStr2)
      var childToStr3 = Object.prototype.hasOwnProperty.call(child, 'toString')
      console.log("child hasOwnProperty " + childToStr3)
    </script>

    <script>
      //apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。
      //唯一的区别就是，它接收一个数组作为函数执行时的参数
      function f(x, y) {
        console.log('x+y=' + (x + y));
      }

      f.apply(this, [5, 9])

      //返回数组的最大元素
      //note:Math.max(value1, value2, ... valueN ) ;
      var numArr = [10, 2, 4, 15, 9];
      var maxNum = Math.max.apply(null, numArr);
      console.log("maxNum=", maxNum)
      //将数组的空元素变为undefined
      var changeArr = ['a', , 'c'];
      var hahhahhahahh = Array.apply(null, changeArr); //0: "a" 1: undefined 2: "c"不会改变原数组
      // debugger
      //note:空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。
      //因此，遍历内部元素的时候，会得到不同的结果。
    </script>

    <script>
      // Function.prototype.bind()
      //bind()方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。
      var date = new Date();
      // var print=date.getTime();
      // console.log("print ",print())
      //bind()方法将getTime()方法内部的this绑定到date对象，
      //这时就可以安全地将这个方法赋值给其他变量了。
      var print = date.getTime.bind(date)
      console.log("print ", print())

      var counter = {
        count: 0,
        inc: function() {
          this.count++
        }
      }
      //bind()方法将inc()内部的this，绑定到counter
      var funinc = counter.inc.bind(counter);
      funinc();
      console.log("count=", counter.count) //1
      //bind()方法将inc()内部的this，绑定到其他对象
      var anotherC = {
        count: 398
      }
      var funanc = counter.inc.bind(anotherC);
      funanc()
      console.log("anotherC.count=", anotherC.count) //399

      var cheng = function(x, y) {
        return x * this.m + y * this.n;
      }

      var chengObj = {
        m: 2,
        n: 3
      };
      var newCheng = cheng.bind(chengObj, 5);
      console.log("cheng=", newCheng(8)) //34

      //1.每次返回一个新函数
      //2.结合回调函数使用
      var e = {
        count: 10,
        inc: function() {
          this.count++
        }
      }

      function callIt(callback) {
        callback()
      }
      callIt(e.inc.bind(e))
      console.log('callit count=', e.count) //1
      
      //3.结合call()方法使用
      //TODO
      
    </script>
  </body>
</html>
